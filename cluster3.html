<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D K-means Demo</title>
  <style>
    :root { color-scheme: dark; }
    body {
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, #0d1a24 0%, #04070d 45%, #04070c 100%);
      color: #dfe9f5;
      margin: 0;
      padding: 24px;
    }
    .shell {
      max-width: 1280px;
      margin: 0 auto;
      background: linear-gradient(135deg, rgba(30,52,74,0.65), rgba(16,26,38,0.82));
      border: 1px solid rgba(255,255,255,0.07);
      box-shadow: 0 30px 80px rgba(0,0,0,0.38), inset 0 1px 0 rgba(255,255,255,0.07);
      border-radius: 16px;
      padding: 18px 18px 10px 18px;
      backdrop-filter: blur(10px);
    }
    .panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px 12px 6px 12px;
    }
    .topline{
      display:flex;
      flex-wrap:wrap;
      justify-content: space-between;
      gap:14px;
      align-items:center;
    }
    .titles .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-size: 11px;
      color: #6cbaff;
    }
    .titles .headline {
      font-weight: 700;
      font-size: 24px;
      color: #e9f3ff;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      flex: 1;
      min-width: 300px;
    }
    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 8px 12px;
      border-radius: 12px;
    }
    .metric{
      display:flex;
      gap:6px;
      align-items: baseline;
      font-size:13px;
      color:#d9e8f7;
    }
    .metric span {
      font-size: 12px;
      color: #b7c6d8;
    }
    .metric strong {
      font-size: 16px;
      color: #ffffff;
    }
    input[type=range] {
      width: 100%;
      accent-color: #5ad1ff;
    }
    label { font-size: 12px; color: #9eb5c9; display: block; }
    .btn-row {
      grid-column: 1 / -1;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }
    .btn {
      border: 1px solid rgba(255,255,255,0.07);
      background: rgba(255,255,255,0.05);
      color: #e8f2ff;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.01em;
      transition: all 0.12s ease;
    }
    .btn:hover { border-color: rgba(90,209,255,0.8); box-shadow: 0 0 0 1px rgba(90,209,255,0.3); }
    .btn.primary { background: linear-gradient(120deg, #2f8bff, #1ddbe0); border-color: transparent; color: #0a1320; }
    .btn.primary:hover { box-shadow: 0 10px 30px rgba(37,139,255,0.3); }
    .btn:active { transform: translateY(1px); }
    .btn.ghost { background: rgba(255,255,255,0.04); }
    .viewport {
      width: 100%;
      height: 720px;
      position: relative;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      background: radial-gradient(circle at 30% 30%, rgba(120,170,230,0.14), rgba(0,0,0,0));
      overflow: hidden;
    }
    .axes-overlay{
      position: absolute;
      left: 12px;
      bottom: 12px;
      width: 180px;
      height: 180px;
      pointer-events: none;
    }
    canvas { display: block; }
    .hint {
      text-align: center;
      color: #8fb2cc;
      font-size: 13px;
      margin: 10px 0 4px;
      letter-spacing: 0.02em;
    }
    .metrics-panel{
      position: fixed;
      right: 18px;
      top: 90px;
      width: 320px;
      padding: 22px 20px;
      border-radius: 14px;
      background: rgba(7,12,18,0.9);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 16px 50px rgba(0,0,0,0.5);
      color: #dfe9f5;
      font-family: "Inter","Segoe UI",system-ui,-apple-system,sans-serif;
      backdrop-filter: blur(12px);
      display: none;
      z-index: 10;
    }
    .metrics-panel h4{
      margin: 0 0 12px 0;
      font-size: 19px;
      letter-spacing: 0.015em;
      color: #8dc8ff;
    }
    .metrics-panel ul{
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 10px;
    }
    .metrics-panel li{
      display: flex;
      justify-content: space-between;
      font-size: 16px;
      color: #cfddee;
    }
    .metrics-panel li span{
      color: #8fb2cc;
    }
    .metrics-panel .traits{
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 12px 0 8px 0;
    }
    .metrics-panel .trait{
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.08);
      color: #dfe9f5;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      letter-spacing: 0.01em;
    }
    .metrics-panel .desc{
      margin-top: 8px;
      font-size: 13px;
      color: #b7c6d8;
      line-height: 1.45;
    }
    @media (max-width: 720px){
      .panel { flex-direction: column; align-items: flex-start; }
      .viewport { height: 420px; }
      .metrics-panel{ display:none !important; }
    }
  </style>  

</head>
<body>
  <div id="app"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.181.2/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/"
  }
}
</script>

<script type ="module">

			import * as THREE from 'three';

      import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
      import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';



    function showError(message){
      console.error(message);
      const note = document.createElement("div");
      note.style.padding = "12px 14px";
      note.style.margin = "16px";
      note.style.borderRadius = "10px";
      note.style.border = "1px solid rgba(255,255,255,0.15)";
      note.style.background = "rgba(30,10,10,0.45)";
      note.style.color = "#ffb7b7";
      note.style.fontFamily = "ui-monospace, SFMono-Regular, Consolas, monospace";
      note.textContent = "3D demo failed to load: " + message;
      document.body.innerHTML = "";
      document.body.appendChild(note);
    }
    window.addEventListener("error", (e)=> showError(e.message || "unknown error"));
    window.addEventListener("unhandledrejection", (e)=> showError(e.reason || "promise rejection"));

    // Small helpers to mimic Observable Inputs without the runtime
    const makeSlider = (min, max, value, step, label) => {
      const wrap = document.createElement("div");
      const lab = document.createElement("label");
      lab.textContent = label;
      const input = document.createElement("input");
      input.type = "range";
      input.min = min;
      input.max = max;
      input.step = step;
      input.value = value;
      wrap.append(lab, input);
      return {node: wrap, input};
    };

    const palette = [
      "#66c2ff","#ff8a4d","#9ae66e","#f04d98","#c592ff",
      "#4de0c4","#ffce5c","#82b0ff","#ff7f7f","#5be37f",
      "#f5a3ff","#7cf5e3"
    ];
    const personaCentroidColors = ["#72e5ff", "#ffc857", "#9bf7a3", "#ff8ad4"];

    let metricsPanel = null;
    let metricItems = null;
    let currentMetricsInst = null;

    // Layout
    const app = document.getElementById("app");
    const shell = document.createElement("div");
    shell.className = "shell";
    shell.innerHTML = `
      <div class="panel">
        <div class="topline">
          <div class="titles">
            <div class="eyebrow">Impact Summit Cluster Demo</div>
            <div class="headline">Interactive 3D K-Means</div>
          </div>
          <div class="metrics">
            <div class="metric"><span>Iteration</span><strong id="iterVal">0</strong></div>
            <div class="metric"><span>SSE</span><strong id="sseVal">--</strong></div>
            <div class="metric"><span>Status</span><strong id="statusVal">idle</strong></div>
            <div class="metric"><span>Points</span><strong id="pointsVal">0</strong></div>
            <div class="metric"><span>Clusters</span><strong id="clustersVal">0</strong></div>
          </div>
        </div>
        <div class="controls"></div>
      </div>
      <div class="viewport" id="viewport"></div>
      <div class="hint">Drag to rotate | Scroll to zoom | Double-click to focus</div>
    `;
    app.appendChild(shell);
    // Metrics side panel
    metricsPanel = document.createElement("div");
    metricsPanel.className = "metrics-panel";
    metricsPanel.innerHTML = `
      <h4 id="metricsTitle">Persona</h4>
      <div class="traits" id="metricTraits"></div>
      <ul>
        <li><span>Churn (X)</span><strong id="metricChurn">--</strong></li>
        <li><span>LTV (Y)</span><strong id="metricLtv">--</strong></li>
        <li><span>Engagement (Z)</span><strong id="metricEngagement">--</strong></li>
        <li><span>Age</span><strong id="metricAge">--</strong></li>
        <li><span>Married</span><strong id="metricMarried">--</strong></li>
        <li><span>Income</span><strong id="metricIncome">--</strong></li>
        <li><span>Homeowner</span><strong id="metricHomeowner">--</strong></li>
        <li><span>Years at location</span><strong id="metricYears">--</strong></li>
        <li><span>Children</span><strong id="metricChildren">--</strong></li>
        <li><span>Preferred Device</span><strong id="metricDevice">--</strong></li>
      </ul>
      <div class="desc" id="metricDesc"></div>
    `;
    document.body.appendChild(metricsPanel);
    metricItems = {
      title: metricsPanel.querySelector("#metricsTitle"),
      traits: metricsPanel.querySelector("#metricTraits"),
      desc: metricsPanel.querySelector("#metricDesc"),
      churn: metricsPanel.querySelector("#metricChurn"),
      ltv: metricsPanel.querySelector("#metricLtv"),
      engagement: metricsPanel.querySelector("#metricEngagement"),
      age: metricsPanel.querySelector("#metricAge"),
      married: metricsPanel.querySelector("#metricMarried"),
      income: metricsPanel.querySelector("#metricIncome"),
      homeowner: metricsPanel.querySelector("#metricHomeowner"),
      years: metricsPanel.querySelector("#metricYears"),
      children: metricsPanel.querySelector("#metricChildren"),
      device: metricsPanel.querySelector("#metricDevice")
    };

    // Controls
    const controls = shell.querySelector(".controls");
    const kSlider = makeSlider(1, 12, 4, 1, "Clusters (k)");
    const nSlider = makeSlider(100, 10000, 100, 50, "Points");
    const spreadSlider = makeSlider(0.08, 0.45, 0.45, 0.01, "Cluster spread");
    const centroidOpacitySlider = makeSlider(0, 1, 1, 0.05, "Centroid opacity");
    const pointOpacitySlider = makeSlider(0, 1, 0.55, 0.05, "Points + lines opacity");
    const btnRow = document.createElement("div");
    btnRow.className = "btn-row";
    const stepBtn = document.createElement("button");
    stepBtn.className = "btn ghost";
    stepBtn.textContent = "Step";
    const runBtn = document.createElement("button");
    runBtn.className = "btn primary";
    runBtn.textContent = "Run";
    const resetBtn = document.createElement("button");
    resetBtn.className = "btn ghost";
    resetBtn.textContent = "Reset";
    const randomBtn = document.createElement("button");
    randomBtn.className = "btn ghost";
    randomBtn.textContent = "Randomize points";
    const axesBtn = document.createElement("button");
    axesBtn.className = "btn ghost";
    axesBtn.textContent = "Hide axes";
    const axisLabelBtn = document.createElement("button");
    axisLabelBtn.className = "btn ghost";
    axisLabelBtn.textContent = "XYZ labels";
    const planesBtn = document.createElement("button");
    planesBtn.className = "btn ghost";
    planesBtn.textContent = "Show planes";
    const cloudBtn = document.createElement("button");
    cloudBtn.className = "btn ghost";
    cloudBtn.textContent = "Show Cloud";
    btnRow.append(stepBtn, runBtn, resetBtn, randomBtn, axesBtn, axisLabelBtn, planesBtn, cloudBtn);
    controls.append(kSlider.node, nSlider.node, spreadSlider.node, centroidOpacitySlider.node, pointOpacitySlider.node, btnRow);

    // State
    let points = [];
    let centroids = [];
    let assignments = [];
    let iteration = 0;
    let centroidOpacity = +centroidOpacitySlider.input.value;
    let pointOpacity = +pointOpacitySlider.input.value;
    let running = null;
    let activeCentroid = null; // selected centroid index or null
    let axesVisible = true;
    let axesScene = null;
    let axesCam = null;
    let axesGroup = null;
    let axesRenderer = null;
    let axesLabelsGroup = null;
    let axisLabelMode = "xyz"; // "metric" or "xyz"
    const axisLen = 80;
    const planeBaseSpan = 500;
    const axesTmp = new THREE.Vector3();
    let planesVisible = false;
    let planeGroup = null;
    let focusedPoint = null;
    let focusedPointKey = null;
    const globeInstances = new Map();
    const globeOrientations = new Map(); // key -> frontDir vector for stable facing
    const personaSlots = [
      {key: "every_day_carry", label: "Every Day Carry", names: ["every_day_carry"]},
      {key: "family_protector", label: "Family Protector", names: ["family_protector"]},
      {key: "new_learner", label: "New Learner", names: ["new_learner"]},
      {key: "range_regular", label: "Range Regular", names: ["range_regular"]}
    ];
    const personaAssets = Array(personaSlots.length).fill(null);
    let personaAssetsPromise = null;
    const globeConfig = {
      globeRadius: 10,
      renderDistance: 520,
      spawnDistance: 760
    };
    let updatingGlobes = false;
    let flyTween = null;

    const iterVal = shell.querySelector("#iterVal");
    const sseVal = shell.querySelector("#sseVal");
    const statusVal = shell.querySelector("#statusVal");
    const pointsVal = shell.querySelector("#pointsVal");
    const clustersVal = shell.querySelector("#clustersVal");

    // Data generation
    function makePoints(n, k, spread){
      const centers = [];
      const radius = 260;
      const box = radius * 1.6;
      const halfBox = box / 2;
      for(let i=0;i<k;i++){
        centers.push([
          Math.random() * box - halfBox,
          Math.random() * box - halfBox,
          Math.random() * box - halfBox
        ]);
      }
      const sigma = Math.max(20, spread * radius);
      return Array.from({length:n}, () => {
        const c = centers[Math.floor(Math.random()*centers.length)];
        const dx = randn()*sigma;
        const dy = randn()*sigma;
        const dz = randn()*sigma*0.8;
        return {
          x: c[0]+dx,
          y: c[1]+dy,
          z: c[2]+dz
        };
      });
    }

    function randBetween(min, max){
      return min + Math.random() * (max - min);
    }


    function randn(){
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function computeBounds(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3();
      box.getSize(size);
      return {box, size, min: box.min.clone(), max: box.max.clone()};
    }


    function fitModelToHeight(model, bounds, targetHeight){
      if(!bounds || !targetHeight) return {lift:0, scale:1};
      const scale = targetHeight / Math.max(bounds.size.y, 1e-4);
      model.scale.setScalar(scale);
      const lift = -bounds.min.y * scale;
      return {lift, scale};
    }

    const metricProfiles = {
      family_protector: {ltv:"mid", engagement:"mid", churn:"low"},
      every_day_carry: {ltv:"mid", engagement:"mid", churn:"mid"},
      range_regular: {ltv:"high", engagement:"high", churn:"low"},
      new_learner: {ltv:"low", engagement:"low", churn:"elevated"},
      placeholder: {ltv:"mid", engagement:"mid", churn:"mid"}
    };
    const personaDetails = {
      family_protector: {
        traits: ["Evening reader", "Household focus", "Opens promos"],
        desc: "Checks updates at night. Prioritizes family safety gear and guidance."
      },
      range_regular: {
        traits: ["Weekend active", "Training content", "Buys in bursts"],
        desc: "Plans range trips on Fri/Sat. Engages with drills and refreshers."
      },
      every_day_carry: {
        traits: ["Commute hours", "Gear-curious", "Saves for later"],
        desc: "Browses EDC tips during commute; compares holsters and quick wins."
      },
      new_learner: {
        traits: ["Early journey", "Short sessions", "Training-first"],
        desc: "Still exploring fundamentals; responds to simple, confidence-building steps."
      }
    };
    const demographicProfiles = {
      family_protector: {
        age: [32, 52],
        marriedProb: 0.78,
        income: [80, 140],
        homeownerProb: 0.7,
        yearsAt: [3, 12],
        children: [1, 3],
        device: ["cell phone", "tablet", "laptop"]
      },
      range_regular: {
        age: [30, 50],
        marriedProb: 0.62,
        income: [75, 140],
        homeownerProb: 0.62,
        yearsAt: [2, 10],
        children: [0, 2],
        device: ["cell phone", "tablet", "laptop"]
      },
      every_day_carry: {
        age: [26, 46],
        marriedProb: 0.45,
        income: [60, 120],
        homeownerProb: 0.5,
        yearsAt: [2, 8],
        children: [0, 2],
        device: ["cell phone", "tablet", "laptop"]
      },
      new_learner: {
        age: [22, 38],
        marriedProb: 0.32,
        income: [45, 95],
        homeownerProb: 0.35,
        yearsAt: [1, 6],
        children: [0, 1],
        device: ["cell phone", "tablet", "laptop"]
      },
      placeholder: {
        age: [26, 48],
        marriedProb: 0.5,
        income: [50, 110],
        homeownerProb: 0.45,
        yearsAt: [1, 8],
        children: [0, 2],
        device: ["cell phone", "tablet", "laptop"]
      }
    };
    function sampleLevel(level, type){
      // Levels mapped to ranges (1-100)
      switch(level){
        case "low": return Math.round(randBetween(8, 30));
        case "mid": return Math.round(randBetween(35, 65));
        case "high": return Math.round(randBetween(70, 95));
        case "elevated": return Math.round(randBetween(60, 85));
        default: return Math.round(randBetween(30, 70));
      }
    }
    function sampleBool(prob){ return Math.random() < prob; }
    function sampleInt(min,max){ return Math.round(randBetween(min,max)); }

    function ensureMetrics(inst){
      if(!inst) return null;
      if(inst.metrics) return inst.metrics;
      const profile = metricProfiles[inst.personaType] || metricProfiles.placeholder;
      const demo = demographicProfiles[inst.personaType] || demographicProfiles.placeholder;
      inst.metrics = {
        churn: sampleLevel(profile.churn, "churn"),
        ltv: sampleLevel(profile.ltv, "ltv"),
        engagement: sampleLevel(profile.engagement, "engagement"),
        age: sampleInt(demo.age[0], demo.age[1]),
        married: sampleBool(demo.marriedProb),
        income: sampleInt(demo.income[0], demo.income[1]),
        homeowner: sampleBool(demo.homeownerProb),
        yearsAt: sampleInt(demo.yearsAt[0], demo.yearsAt[1]),
        children: sampleInt(demo.children[0], demo.children[1]),
        device: demo.device[Math.floor(Math.random() * demo.device.length)]
      };
      return inst.metrics;
    }

    function hideMetricsPanel(){
      currentMetricsInst = null;
      if(metricsPanel) metricsPanel.style.display = "none";
    }
    function showMetricsPanel(inst){
      if(!inst || !metricItems || !metricsPanel) return hideMetricsPanel();
      const metrics = ensureMetrics(inst);
      const name = inst.persona?.label || inst.personaType || "Persona";
      metricItems.title.textContent = name;
      const detail = personaDetails[inst.personaType] || personaDetails.placeholder || {traits:[], desc:""};
      if(metricItems.traits){
        metricItems.traits.innerHTML = "";
        detail.traits.forEach(t=>{
          const span = document.createElement("span");
          span.className = "trait";
          span.textContent = t;
          metricItems.traits.appendChild(span);
        });
      }
      if(metricItems.desc){
      metricItems.desc.textContent = detail.desc || "";
    }
    metricItems.churn.textContent = `${metrics.churn}`;
    metricItems.ltv.textContent = `${metrics.ltv}`;
    metricItems.engagement.textContent = `${metrics.engagement}`;
    if(metricItems.age) metricItems.age.textContent = `${metrics.age}`;
    if(metricItems.married) metricItems.married.textContent = metrics.married ? "Yes" : "No";
    if(metricItems.income) metricItems.income.textContent = `$${metrics.income}k`;
    if(metricItems.homeowner) metricItems.homeowner.textContent = metrics.homeowner ? "Yes" : "No";
    if(metricItems.years) metricItems.years.textContent = `${metrics.yearsAt} yr${metrics.yearsAt === 1 ? "" : "s"}`;
    if(metricItems.children) metricItems.children.textContent = `${metrics.children}`;
    if(metricItems.device) metricItems.device.textContent = metrics.device || "--";
    metricsPanel.style.display = "block";
    currentMetricsInst = inst;
  }

    // K-means helpers
    function jitteredCopy(p){
      return {
        x: p.x + randBetween(-1, 1),
        y: p.y + randBetween(-1, 1),
        z: p.z + randBetween(-1, 1)
      };
    }

    function seedCentroidsFromPoints(k){
      if(points.length === 0) return [];
      const maxK = Math.min(k, points.length);
      const chosen = [];
      const pick = idx => jitteredCopy(points[idx]);

      let firstIdx = Math.floor(Math.random() * points.length);
      chosen.push(pick(firstIdx));

      while(chosen.length < maxK){
        const distances = points.map(pt=>{
          let best = Infinity;
          for(const c of chosen){
            const dx = pt.x - c.x;
            const dy = pt.y - c.y;
            const dz = pt.z - c.z;
            const d2 = dx*dx + dy*dy + dz*dz;
            if(d2 < best) best = d2;
          }
          return best;
        });
        const total = distances.reduce((a,b)=> a + b, 0);
        let r = Math.random() * (total || points.length);
        let idx = 0;
        for(let i=0;i<distances.length;i++){
          r -= distances[i] || 1;
          if(r <= 0){ idx = i; break; }
        }
        chosen.push(pick(idx));
      }
      return chosen;
    }

    function farthestPointFrom(centers){
      if(points.length === 0) return null;
      if(!centers || !centers.length) return points[Math.floor(Math.random()*points.length)];
      let bestIdx = 0, bestDist = -Infinity;
      for(let i=0;i<points.length;i++){
        const p = points[i];
        let nearest = Infinity;
        for(const c of centers){
          const dx = p.x - c.x;
          const dy = p.y - c.y;
          const dz = p.z - c.z;
          const d2 = dx*dx + dy*dy + dz*dz;
          if(d2 < nearest) nearest = d2;
        }
        if(nearest > bestDist){
          bestDist = nearest;
          bestIdx = i;
        }
      }
      return points[bestIdx];
    }

    function init(k){
      if(points.length === 0){
        points = makePoints(+nSlider.input.value, k, +spreadSlider.input.value);
        clearFocusedPoint();
      }
      centroids = seedCentroidsFromPoints(k);
      assignments = new Array(points.length).fill(-1);
      iteration = 0;
      assign();
      updateCentroids();
      updateLabels("ready");
      update3D();
      if(planesVisible) updatePlaneOrigin();
    }

    function assign(){
      let changed = false;
      for(let i=0;i<points.length;i++){
        let best = -1, bestDist = Infinity;
        for(let j=0;j<centroids.length;j++){
          const dx = points[i].x - centroids[j].x;
          const dy = points[i].y - centroids[j].y;
          const dz = points[i].z - centroids[j].z;
          const d2 = dx*dx + dy*dy + dz*dz;
          if(d2 < bestDist){
            bestDist = d2;
            best = j;
          }
        }
        if(assignments[i] !== best){
          assignments[i] = best;
          changed = true;
        }
      }
      return changed;
    }

    function updateCentroids(){
      const sums = centroids.map(()=>({x:0,y:0,z:0,count:0}));
      for(let i=0;i<points.length;i++){
        const a = assignments[i];
        if(a>=0){
          sums[a].x += points[i].x;
          sums[a].y += points[i].y;
          sums[a].z += points[i].z;
          sums[a].count += 1;
        }
      }
      let moved = false;
      const nonEmpty = centroids.filter((_, idx)=> sums[idx].count > 0);
      for(let j=0;j<centroids.length;j++){
        if(sums[j].count === 0){
          const p = farthestPointFrom(nonEmpty) || points[Math.floor(Math.random() * points.length)];
          centroids[j].x = p.x + randBetween(-1, 1);
          centroids[j].y = p.y + randBetween(-1, 1);
          centroids[j].z = p.z + randBetween(-1, 1);
          moved = true;
          continue;
        }
        if(sums[j].count > 0){
          const nx = sums[j].x / sums[j].count;
          const ny = sums[j].y / sums[j].count;
          const nz = sums[j].z / sums[j].count;
          const delta = Math.hypot(nx-centroids[j].x, ny-centroids[j].y, nz-centroids[j].z);
          centroids[j].x = nx; centroids[j].y = ny; centroids[j].z = nz;
          if(delta > 1e-4) moved = true;
        }
      }
      return moved;
    }

    function sse(){
      let total = 0;
      for(let i=0;i<points.length;i++){
        const a = assignments[i];
        if(a>=0){
          const dx = points[i].x - centroids[a].x;
          const dy = points[i].y - centroids[a].y;
          const dz = points[i].z - centroids[a].z;
          total += dx*dx + dy*dy + dz*dz;
        }
      }
      return total;
    }

    function step(){
      if(centroids.length === 0) return;
      const changed = assign();
      const moved = updateCentroids();
      iteration += 1;
      updateLabels(changed || moved ? "iterating" : "converged");
      update3D();
      if(!changed && !moved) stop();
      return changed || moved;
    }

    function run(){
      stop();
      running = setInterval(()=> step(), 220);
      updateLabels("running");
    }
    function stop(){
      if(running){ clearInterval(running); running = null; }
    }
    function clearFocusedPoint(){
      focusedPoint = null;
      focusedPointKey = null;
    }
    function reset(){
      stop();
      points = [];
      centroids = [];
      assignments = [];
      iteration = 0;
      activeCentroid = null;
      clearFocusedPoint();
      disposeAllGlobes();
      updateLabels("idle");
      update3D();
    }

    function updateLabels(state){
      iterVal.textContent = iteration.toString();
      sseVal.textContent = centroids.length ? sse().toFixed(1) : "--";
      statusVal.textContent = state;
      pointsVal.textContent = points.length.toString();
      clustersVal.textContent = centroids.length.toString();
    }

    // UI wiring
    stepBtn.onclick = ()=>{ if(!centroids.length) init(+kSlider.input.value); step(); };
    runBtn.onclick = ()=>{
      if(running){ stop(); runBtn.textContent = "Run"; statusVal.textContent = "paused"; }
      else { if(!centroids.length) init(+kSlider.input.value); run(); runBtn.textContent = "Pause"; }
    };
    resetBtn.onclick = ()=>{ reset(); runBtn.textContent = "Run"; };
    randomBtn.onclick = ()=>{
      stop();
      points = makePoints(+nSlider.input.value, +kSlider.input.value, +spreadSlider.input.value);
      centroids = [];
      assignments = [];
      iteration = 0;
      clearFocusedPoint();
      disposeAllGlobes();
      hideMetricsPanel();
      updateLabels("new sample");
      update3D();
      runBtn.textContent = "Run";
      if(planesVisible) updatePlaneOrigin();
    };

    function updateCountsFromSliders(){
      clustersVal.textContent = kSlider.input.value;
      pointsVal.textContent = nSlider.input.value;
    }

    kSlider.input.oninput = ()=>{ updateCountsFromSliders(); if(centroids.length) init(+kSlider.input.value); };
    nSlider.input.oninput = ()=>{ updateCountsFromSliders(); };
    centroidOpacitySlider.input.oninput = ()=>{ centroidOpacity = +centroidOpacitySlider.input.value; update3D(); };
    pointOpacitySlider.input.oninput = ()=>{ pointOpacity = +pointOpacitySlider.input.value; update3D(); };

    // 3D scene setup
    const viewport = shell.querySelector("#viewport");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x12243a);
    scene.fog = new THREE.FogExp2(0x12243a, 0.00045);

    const camera = new THREE.PerspectiveCamera(48, 16/9, 1, 5000);
    camera.position.set(0, 0, 900);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    viewport.appendChild(renderer.domElement);
    // Add a lightweight generated environment map so metallic materials have reflections
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envTexture = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
    scene.environment = envTexture;
    pmrem.dispose();

    axesRenderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    axesRenderer.setPixelRatio(window.devicePixelRatio || 1);
    axesRenderer.setSize(180, 180);
    axesRenderer.setClearColor(0x000000, 0);
    axesRenderer.domElement.className = "axes-overlay";
    axesRenderer.domElement.style.display = axesVisible ? "block" : "none";
    axesRenderer.domElement.style.pointerEvents = "auto";
    viewport.appendChild(axesRenderer.domElement);
    axesRenderer.domElement.addEventListener("click", orientCameraToAxes);

    async function loadWithFallback(loader, baseName){
      try{
        return await loader.loadAsync(`${baseName}.glb`);
      }catch(err){
        console.warn(`${baseName}.glb failed, falling back to .gltf`, err);
        return loader.loadAsync(`${baseName}.gltf`);
      }
    }

    function loadPersonaAssets(){
      if(personaAssetsPromise) return personaAssetsPromise;
      const loader = new GLTFLoader().setPath("./");
      personaAssetsPromise = Promise.all(
        personaSlots.map(async (slot)=>{
          for(const name of slot.names){
            try{
              const gltf = await loadWithFallback(loader, name);
              const model = gltf?.scene || gltf?.scenes?.[0];
              if(!model) continue;
              model.updateMatrixWorld(true);
              const bounds = computeBounds(model);
              return {model, bounds, label: slot.label, nameLoaded: name, type: slot.key};
            }catch(err){
              console.warn(`Failed to load ${name}`, err);
            }
          }
          return null;
        })
      ).then(results=>{
        results.forEach((res, idx)=> {
          personaAssets[idx] = res || buildPlaceholderPersona(personaSlots[idx]?.label || "Persona");
        });
        console.log("Persona assets ready:", personaAssets.map(p=>p?.label || "missing"));
        return personaAssets;
      }).catch(err=>{
        console.error("Failed to load persona assets", err);
        personaAssetsPromise = null;
        return null;
      });
      return personaAssetsPromise;
    }

    function disposeGlobeInstance(inst){
      if(!inst || !inst.group) return;
      scene.remove(inst.group);
      inst.group.traverse(obj=>{
        if(obj.userData && obj.userData.cleanup){
          const disposeMat = (m)=>{
            if(!m) return;
            if(m.map && m.map.dispose) m.map.dispose();
            if(m.dispose) m.dispose();
          };
          if(obj.geometry && obj.geometry.dispose) obj.geometry.dispose();
          if(obj.material){
            if(Array.isArray(obj.material)){
              obj.material.forEach(disposeMat);
            }else{
              disposeMat(obj.material);
            }
          }
        }
      });
    }

    function disposeAllGlobes(){
      globeInstances.forEach(inst => disposeGlobeInstance(inst));
      globeInstances.clear();
      globeOrientations.clear();
      hideMetricsPanel();
    }

    function computePersonaRadius(persona){
      if(!persona || !persona.bounds) return globeConfig.globeRadius;
      const size = persona.bounds.size;
      const maxDim = Math.max(size.x, size.y, size.z, 1e-4);
      const radiusFromBounds = (maxDim * 1.25) * 0.5; // 25% diameter margin to avoid clipping
      return Math.max(radiusFromBounds, globeConfig.globeRadius * 0.6);
    }

    function buildPlaceholderPersona(name){
      const geom = new THREE.CapsuleGeometry(6, 6, 10, 16);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x5ad1ff,
        emissive: 0x2f7aa2,
        metalness: 0.4,
        roughness: 0.2
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.userData.cleanup = true;
      const group = new THREE.Group();
      group.add(mesh);
      group.userData.placeholderName = name || "Persona";
      group.userData.bounds = computeBounds(group);
      return {model: group, bounds: group.userData.bounds, label: name || "Persona", type: "placeholder"};
    }

    function buildPersonaGlobe(persona, radiusOverride, frontOverride){
      if(!persona || !persona.model || !persona.bounds) return null;
      const radius = radiusOverride ?? computePersonaRadius(persona);
      const group = new THREE.Group();
      const groundY = -radius * 0.9;

      const glass = new THREE.Mesh(
        new THREE.SphereGeometry(radius, 20, 16),
        new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          emissive: 0x1a2d46,
          emissiveIntensity: 0.35,
          transparent: true,
          opacity: 0.12,
          roughness: 0.012,
          metalness: 0.035,
          transmission: 0.975,
          thickness: 1.1,
          envMapIntensity: 1.0,
          clearcoat: 0.76,
          clearcoatRoughness: 0.035,
          depthWrite: false
        })
      );
      glass.userData.cleanup = true;
      group.add(glass);

      const interior = new THREE.Group();
      interior.userData.isInterior = true;
      const facing = (frontOverride && frontOverride.lengthSq() > 0)
        ? Math.atan2(frontOverride.x, frontOverride.z)
        : Math.random() * Math.PI * 2;
      const figure = SkeletonUtils.clone(persona.model);
      const fit = fitModelToHeight(figure, persona.bounds, radius * 1.6); // target ~80% of diameter
      figure.rotation.y = facing;
      figure.position.y = groundY + fit.lift;
      interior.add(figure);

      const accentLight = new THREE.PointLight(0x6cd0ff, 0.65, radius * 7.5, 2.1);
      accentLight.position.set(0, radius * 0.7, 0);
      accentLight.userData.cleanup = true;
      interior.add(accentLight);

      group.add(interior);
      const frontDir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), facing); // model forward after yaw
      return {group, glass, interior, persona, frontDir};
    }

    function setGlobeInteriorVisibility(inst, visible){
      if(!inst) return;
      if(inst.interior) inst.interior.visible = visible;
      if(inst.group){
        inst.group.children.forEach(child=>{
          if(child.userData && child.userData.isInterior && child !== inst.interior){
            child.visible = visible;
          }
        });
      }
    }

    function updatePersonaGlobeAppearance(glass, distance, visibilityT){
      if(!glass || !glass.material) return;
      const mat = glass.material;
      const t = THREE.MathUtils.clamp(visibilityT ?? 0, 0, 1);
      mat.opacity = THREE.MathUtils.lerp(0.015, 0.18, t);
      mat.emissiveIntensity = THREE.MathUtils.lerp(0.05, 0.6, t);
      mat.thickness = THREE.MathUtils.lerp(0.9, 2.0, t);
      mat.needsUpdate = true;
    }

    function updateGlobeVisibilityState(inst, dist){
      if(!inst || !inst.group) return;
      const spawnDist = inst.spawnDist ?? globeConfig.spawnDistance;
      const interiorDist = inst.renderDist ?? globeConfig.renderDistance;
      const minScale = 0.08;
      const maxScale = 1.0;
      const range = Math.max(spawnDist - interiorDist, 1);
      const tRaw = THREE.MathUtils.clamp((spawnDist - dist) / range, 0, 1);
      const t = tRaw * tRaw * (3 - 2 * tRaw); // smoothstep easing for a softer grow-in
      const scale = THREE.MathUtils.lerp(minScale, maxScale, t);
      inst.group.scale.setScalar(scale);
      setGlobeInteriorVisibility(inst, true);
      updatePersonaGlobeAppearance(inst.glass, dist, t);
    }

    function updateVisibleGlobes(){
      if(updatingGlobes) return;
      updatingGlobes = true;
      (async ()=>{
        if(!centroids || centroids.length === 0){
          disposeAllGlobes();
          return;
        }
        const limit = Math.min(centroids.length, personaSlots.length, 4);
        // Only show globes when a persona centroid is explicitly active/highlighted
        if(activeCentroid === null || activeCentroid >= limit){
          disposeAllGlobes();
          return;
        }
        await loadPersonaAssets();

        const visibleIds = new Set();
        const ndc = new THREE.Vector3();
        const radius = globeConfig.globeRadius;
        const spawnDist = globeConfig.spawnDistance;

        const anchors = [];
        const seenClusters = new Set();
        for(let pIdx=0; pIdx<points.length; pIdx++){
          const a = assignments[pIdx];
          if(a === undefined || a === null) continue;
          if(a !== activeCentroid) continue;
          const p = points[pIdx];
          if(!p) continue;
          anchors.push({
            slot: activeCentroid,
            key: `p-${pIdx}`,
            pos: new THREE.Vector3(p.x, p.y, p.z)
          });
          seenClusters.add(activeCentroid);
        }
        // fallback: if a cluster has no points yet, place one globe at the centroid
        if(!seenClusters.has(activeCentroid)){
          const c = centroids[activeCentroid];
          if(c){
            anchors.push({
              slot: activeCentroid,
              key: `c-${activeCentroid}`,
              pos: new THREE.Vector3(c.x, c.y, c.z)
            });
          }
        }

        anchors.forEach(anchor=>{
          ndc.copy(anchor.pos).project(camera);
          const onScreen = Math.abs(ndc.x) <= 1.2 && Math.abs(ndc.y) <= 1.2 && ndc.z >= -1 && ndc.z <= 1;
          if(!onScreen) return;
          const existing = globeInstances.get(anchor.key);
          const persona = personaAssets[anchor.slot] || buildPlaceholderPersona(personaSlots[anchor.slot]?.label || "Persona");
          const radiusUsed = existing?.radius ?? computePersonaRadius(persona);
          const spawnScaled = globeConfig.spawnDistance * (radiusUsed / globeConfig.globeRadius);
          const renderScaled = globeConfig.renderDistance * (radiusUsed / globeConfig.globeRadius);
          const dist = camera.position.distanceTo(anchor.pos);
          const diameterFraction = (2 * radiusUsed / Math.max(dist, 1e-4)) / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
          if(diameterFraction < 0.005 && dist > radiusUsed * 25) return;
          const withinSpawn = dist <= spawnScaled;
          if(!existing && !withinSpawn) return; // don't spawn new globes until close enough

          let built = null;
          let inst = existing;
          if(!inst && persona && persona.model){
            const savedFront = globeOrientations.get(anchor.key);
            built = buildPersonaGlobe(persona, radiusUsed, savedFront);
            if(built){
              inst = built;
              inst.globeIdx = anchor.slot;
              inst.radius = radiusUsed;
              inst.spawnDist = spawnScaled;
              inst.renderDist = renderScaled;
              inst.frontDir = built.frontDir || new THREE.Vector3(0,0,1);
              inst.personaType = persona?.type || personaSlots[anchor.slot]?.key || "persona";
              if(inst.group) inst.group.userData.globeInst = inst;
              if(inst.glass) inst.glass.userData.globeInst = inst;
              globeInstances.set(anchor.key, inst);
              scene.add(inst.group);
            }
          }
          if(inst){
            inst.radius = radiusUsed;
            inst.spawnDist = spawnScaled;
            inst.renderDist = renderScaled;
            if(!inst.frontDir) inst.frontDir = (built?.frontDir || globeOrientations.get(anchor.key) || new THREE.Vector3(0,0,1));
            if(!inst.personaType) inst.personaType = persona?.type || personaSlots[anchor.slot]?.key || "persona";
            globeOrientations.set(anchor.key, inst.frontDir.clone());
            visibleIds.add(anchor.key);
            inst.group.position.copy(anchor.pos);
            updateGlobeVisibilityState(inst, dist);
          }
        });

        globeInstances.forEach((inst, id)=>{
          if(!visibleIds.has(id)){
            disposeGlobeInstance(inst);
            globeInstances.delete(id);
          }
        });
      })().catch(err=>console.error(err)).finally(()=>{ updatingGlobes = false; });
    }
    // Lightweight camera controls (orbit + zoom)
    function makeSimpleOrbit(camera, dom){
      const target = new THREE.Vector3(0,0,0);
      const spherical = new THREE.Spherical();
      let isDragging = false;
      let lastX = 0, lastY = 0;
      let azVel = 0, elVel = 0, distVel = 0;
      const rotateSpeed = 0.005;
      const zoomSpeed = 0.15;
      const minDist = 5, maxDist = 3000;

      function syncFromCamera(){
        const offset = camera.position.clone().sub(target);
        spherical.setFromVector3(offset);
      }
      syncFromCamera();

      function applyMovement(){
        spherical.theta += azVel;
        spherical.phi += elVel;
        spherical.radius = THREE.MathUtils.clamp(spherical.radius + distVel, minDist, maxDist);
        spherical.phi = THREE.MathUtils.clamp(spherical.phi, 0.05, Math.PI-0.05);
        const pos = new THREE.Vector3().setFromSpherical(spherical).add(target);
        camera.position.copy(pos);
        camera.lookAt(target);
        azVel *= 0.92; elVel *= 0.92; distVel *= 0.6;
      }

      function onDown(e){
        isDragging = true;
        lastX = e.clientX; lastY = e.clientY;
        dom.style.cursor = "grabbing";
      }
      function onMove(e){
        if(!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        azVel = -dx * rotateSpeed;
        elVel = -dy * rotateSpeed;
        lastX = e.clientX; lastY = e.clientY;
        e.preventDefault();
      }
      function onUp(){
        isDragging = false;
        dom.style.cursor = "grab";
      }
      function onWheel(e){
        distVel += e.deltaY * zoomSpeed;
        e.preventDefault();
      }
      function focusOnPosition(pos, radius){
        target.copy(pos);
        syncFromCamera();
        const desired = radius ?? spherical.radius;
        spherical.radius = THREE.MathUtils.clamp(desired, minDist, maxDist);
        const newPos = new THREE.Vector3().setFromSpherical(spherical).add(target);
        camera.position.copy(newPos);
        camera.lookAt(target);
      }
      function setPose(pos, tgt){
        target.copy(tgt);
        const offset = pos.clone().sub(target);
        spherical.setFromVector3(offset);
        camera.position.copy(pos);
        camera.lookAt(target);
        azVel = 0; elVel = 0; distVel = 0;
      }
      function focusOnData(){
        if(Array.isArray(points) && points.length){
          let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
          for(const p of points){
            if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
            if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
            if(p.z<minZ) minZ=p.z; if(p.z>maxZ) maxZ=p.z;
          }
          const cx = (minX+maxX)/2, cy = (minY+maxY)/2, cz = (minZ+maxZ)/2;
          const span = Math.max(maxX-minX, maxY-minY, maxZ-minZ, 80);
          const radius = Math.max(span * 1.2, minDist * 1.1);
          focusOnPosition(new THREE.Vector3(cx, cy, cz), radius);
        }else{
          focusOnPosition(new THREE.Vector3(0,0,0), minDist * 1.5);
        }
      }
      dom.addEventListener("pointerdown", onDown);
      window.addEventListener("pointermove", onMove);
      window.addEventListener("pointerup", onUp);
      dom.addEventListener("wheel", onWheel, {passive:false});

      return { update: applyMovement, target, focusOnData, focusOnPosition, setPose };
    }

    const controls3d = makeSimpleOrbit(camera, renderer.domElement);
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function startFlyToPersona(inst){
      if(!inst || !inst.group) return;
      flyTween = null;
      const basePos = inst.group.position.clone();
      const radius = inst.radius || globeConfig.globeRadius;
      const forward = (inst.frontDir ? inst.frontDir.clone() : new THREE.Vector3(0,0,1)).normalize();
      const desiredFrac = 0.85; // back off ~20% from previous framing
      const fovRad = THREE.MathUtils.degToRad(camera.fov);
      const idealDist = (radius) / (Math.tan(fovRad * 0.5) * desiredFrac);
      const distance = Math.max(idealDist, radius * 0.8, 12);
      const endPos = basePos.clone().add(forward.clone().multiplyScalar(distance)).add(new THREE.Vector3(0, radius * 0.25, 0));
      const startPos = camera.position.clone();
      const startTarget = controls3d.target.clone();
      const endTarget = basePos.clone();
      flyTween = {
        startTime: performance.now(),
        duration: 1800,
        startPos,
        endPos,
        startTarget,
        endTarget,
        inst
      };
    }

    function focusCameraOnCentroid(idx){
      if(idx === null || idx === undefined) return;
      const c = centroids[idx];
      if(!c) return;
      const pos = new THREE.Vector3(c.x, c.y, c.z);
      const dist = Math.max(globeConfig.globeRadius * 12, 180);
      controls3d.focusOnPosition(pos, dist);
    }

    function orientCameraToAxes(){
      const target = new THREE.Vector3(0,0,0);
      const dist = Math.max(camera.position.distanceTo(controls3d.target || target), 150);
      const pos = new THREE.Vector3(0,0,dist);
      controls3d.setPose(pos, target);
    }

    function pickCentroid(event){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(centroidMeshes, false);
      if(hits && hits.length){
        const idx = hits[0].object.userData.index;
        if(idx === activeCentroid) activeCentroid = null;
        else activeCentroid = idx;
        hideMetricsPanel();
        if(activeCentroid !== null) focusCameraOnCentroid(activeCentroid);
        else controls3d.focusOnData();
        update3D();
      }
    }
    renderer.domElement.addEventListener("click", pickCentroid);

    function setFocusedPointFromHit(hit){
      const focusPos = hit.point.clone();
      let clusterId = null;
      let instanceId = null;
      if(hit.object && hit.object.isInstancedMesh && typeof hit.instanceId === "number"){
        const pts = hit.object.userData?.points;
        if(Array.isArray(pts) && pts[hit.instanceId]){
          const p = pts[hit.instanceId];
          focusPos.set(p.x, p.y, p.z);
        }
        clusterId = hit.object.userData?.clusterId ?? null;
        instanceId = hit.instanceId;
      }
      const key = `${clusterId ?? "x"}:${instanceId ?? "p"}:${focusPos.x.toFixed(2)},${focusPos.y.toFixed(2)},${focusPos.z.toFixed(2)}`;
      focusedPointKey = key;
      focusedPoint = {position: focusPos, clusterId, instanceId};
    }

    function focusOnPointDoubleClick(event){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const candidates = pointsGroup ? pointsGroup.children.slice() : [];
      globeInstances.forEach(inst => {
        if(inst && inst.glass){
          candidates.push(inst.glass);
        }
      });
      const hits = raycaster.intersectObjects(candidates, true);
      if(hits && hits.length){
        const hit = hits[0];
        const inst = hit.object?.userData?.globeInst;
        if(inst){
          startFlyToPersona(inst);
          event.preventDefault();
          return;
        } else {
          setFocusedPointFromHit(hit);
          const focusPos = focusedPoint.position;
          const desiredHeight = globeConfig.globeRadius * 2.4;
          const requiredDist = desiredHeight / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
          controls3d.focusOnPosition(focusPos, requiredDist * 1.05);
          updateVisibleGlobes();
          event.preventDefault();
          return;
        }
      }
      clearFocusedPoint();
      controls3d.focusOnData();
      hideMetricsPanel();
    }
    renderer.domElement.addEventListener("dblclick", focusOnPointDoubleClick);
    axesBtn.onclick = ()=>{
      axesVisible = !axesVisible;
      axesBtn.textContent = axesVisible ? "Hide axes" : "Show axes";
      ensureAxes();
      if(axesRenderer){
        axesRenderer.domElement.style.display = axesVisible ? "block" : "none";
      }
    };
    axisLabelBtn.onclick = ()=>{
      axisLabelMode = axisLabelMode === "metric" ? "xyz" : "metric";
      axisLabelBtn.textContent = axisLabelMode === "metric" ? "Metric labels" : "XYZ labels";
      ensureAxes();
      rebuildAxisLabels();
    };
    planesBtn.onclick = ()=> togglePlanes();
    cloudBtn.onclick = () => {
      cloudsVisible = !cloudsVisible;
      cloudBtn.textContent = cloudsVisible ? "Hide Cloud" : "Show Cloud";
      update3D(); // rebuild hulls for the current clustering
    };

    // Lighting and atmosphere
    const ambi = new THREE.AmbientLight( 0x404040,2.4 ); // softer ambient to keep shading readable
    scene.add(ambi);
    const hemi = new THREE.HemisphereLight(0xb7e4ff, 0x1c283a, 1.1);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.65);
    dir.position.set(1.4, 1.7, 2.3);
    scene.add(dir);
    const fill = new THREE.DirectionalLight(0x7fb3ff, 0.7);
    fill.position.set(-1.6, 0.9, 0.6);
    scene.add(fill);
    const rim = new THREE.PointLight(0x9ad9ff, 1.1, 2000, 1.3);
    rim.position.set(-760, -60, 720);
    scene.add(rim);

    // Geometry holders
    const pointBaseGeom = new THREE.SphereGeometry(1.1, 14, 12);
    const pointMat = new THREE.MeshStandardMaterial({
      vertexColors: true,
      emissive: 0xa6e0e0,
      emissiveIntensity: 10.0,
      roughness: 0.3,
      metalness: 0.08,
      transparent: true,
      opacity: pointOpacity
    });
    let pointsGroup = null;

    let centroidMeshes = [];
    let linkGeom = new THREE.BufferGeometry();
    let linkMat = new THREE.LineBasicMaterial({color:0x9fb5c8, transparent:true, opacity:0.25});
    let linkLines = new THREE.LineSegments(linkGeom, linkMat);
    let clusterCloudGroup = null;
    let cloudsVisible = false;

    scene.add(linkLines);

    function resize(){
      const w = viewport.clientWidth || 960;
      const h = Math.max(620, Math.round(w*0.65));
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      if(axesRenderer){
        const axesSize = Math.min(Math.min(w, h) * 0.25, 220);
        axesRenderer.setSize(axesSize, axesSize);
        axesRenderer.domElement.style.width = `${axesSize}px`;
        axesRenderer.domElement.style.height = `${axesSize}px`;
      }
    }
    window.addEventListener("resize", resize);
    resize();

    function makeAxisLabel(text, color, position){
      const size = 360;
      const canvas = document.createElement("canvas");
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,size,size);
      ctx.fillStyle = color;
      ctx.font = "bold 120px Inter, Arial, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, size/2, size/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      const mat = new THREE.SpriteMaterial({map: tex, depthTest:false, transparent:true, opacity: 0.9});
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(30,30,30);
      sprite.position.copy(position);
      return sprite;
    }

    function rebuildAxisLabels(){
      if(!axesGroup) return;
      if(axesLabelsGroup){
        axesGroup.remove(axesLabelsGroup);
      }
      axesLabelsGroup = new THREE.Group();
      const labels = axisLabelMode === "xyz" ? ["X","Y","Z"] : ["Churn","LTV","Eng"];
      axesLabelsGroup.add(makeAxisLabel(labels[0], "#ff7b7b", new THREE.Vector3(axisLen+12,0,0)));
      axesLabelsGroup.add(makeAxisLabel(labels[1], "#7bff9c", new THREE.Vector3(0,axisLen+12,0)));
      axesLabelsGroup.add(makeAxisLabel(labels[2], "#7cb8ff", new THREE.Vector3(0,0,axisLen+12)));
      axesGroup.add(axesLabelsGroup);
    }

    function ensureAxes(){
      if(axesScene) return;
      axesScene = new THREE.Scene();
      axesCam = new THREE.PerspectiveCamera(45, 1, 0.1, 1500);
      axesCam.position.set(200, 200, 200);
      axesCam.lookAt(0,0,0);
      axesGroup = new THREE.Group();
      const helper = new THREE.AxesHelper(axisLen);
      helper.material.depthTest = false;
      helper.material.transparent = true;
      helper.material.opacity = 0.85;
      axesGroup.add(helper);
      rebuildAxisLabels();
      axesScene.add(axesGroup);
    }

    function buildPlanes(){
      if(planeGroup) return planeGroup;
      planeGroup = new THREE.Group();
      const matX = new THREE.MeshBasicMaterial({color: 0xff7b7b, transparent:true, opacity:0.05, side:THREE.DoubleSide, depthWrite:false});
      const matY = new THREE.MeshBasicMaterial({color: 0x7bff9c, transparent:true, opacity:0.05, side:THREE.DoubleSide, depthWrite:false});
      const matZ = new THREE.MeshBasicMaterial({color: 0x7cb8ff, transparent:true, opacity:0.05, side:THREE.DoubleSide, depthWrite:false});
      // Extend only into the positive quadrant
      const half = planeBaseSpan * 0.5;
      const gXY = new THREE.PlaneGeometry(planeBaseSpan, planeBaseSpan);
      gXY.translate(half, half, 0);
      const planeXY = new THREE.Mesh(gXY, matZ); // floor z=0

      const gXZ = new THREE.PlaneGeometry(planeBaseSpan, planeBaseSpan);
      gXZ.rotateX(Math.PI/2);
      gXZ.translate(half, 0, half);
      const planeXZ = new THREE.Mesh(gXZ, matY); // wall y=0

      const gYZ = new THREE.PlaneGeometry(planeBaseSpan, planeBaseSpan);
      gYZ.rotateY(Math.PI/2);
      gYZ.translate(0, half, half);
      const planeYZ = new THREE.Mesh(gYZ, matX); // wall x=0

      // Intersection guide lines (positive directions)
      const lineMat = new THREE.LineBasicMaterial({color: 0xffffff, transparent:true, opacity:0.25});
      const lineGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0,0,0), new THREE.Vector3(planeBaseSpan,0,0),
        new THREE.Vector3(0,0,0), new THREE.Vector3(0,planeBaseSpan,0),
        new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,planeBaseSpan)
      ]);
      const lines = new THREE.LineSegments(lineGeom, lineMat);

      planeGroup.add(planeXY, planeXZ, planeYZ, lines);
      planeGroup.renderOrder = -1;
      return planeGroup;
    }

    function updatePlaneOrigin(){
      if(!planeGroup) return;
      if(!points || !points.length){
        planeGroup.position.set(0,0,0);
        planeGroup.scale.setScalar(1);
        return;
      }
      let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
      for(const p of points){
        if(!p) continue;
        if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
        if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
        if(p.z<minZ) minZ=p.z; if(p.z>maxZ) maxZ=p.z;
      }
      const margin = 25;
      const spanX = (maxX - minX) + margin * 2;
      const spanY = (maxY - minY) + margin * 2;
      const spanZ = (maxZ - minZ) + margin * 2;
      const needed = Math.max(spanX, spanY, spanZ, planeBaseSpan);
      const scale = needed / planeBaseSpan;
      planeGroup.position.set(minX - margin, minY - margin, minZ - margin);
      planeGroup.scale.setScalar(scale);
    }

    function togglePlanes(force){
      const want = force ?? !planesVisible;
      planesVisible = want;
      if(!planeGroup) buildPlanes();
      if(planesVisible){
        if(planeGroup && !scene.children.includes(planeGroup)) scene.add(planeGroup);
        updatePlaneOrigin();
        orientCameraToAxes(); // reframe to canonical view when planes come on
      }else{
        if(planeGroup) scene.remove(planeGroup);
      }
      planesBtn.textContent = planesVisible ? "Hide planes" : "Show planes";
    }
    function clearClouds(){
      if(!clusterCloudGroup) return;
      scene.remove(clusterCloudGroup);
      clusterCloudGroup.traverse(obj => {
        if (obj.isMesh) {
          if (obj.geometry) obj.geometry.dispose();
          if (Array.isArray(obj.material)) {
            obj.material.forEach(m => m && m.dispose && m.dispose());
          } else if (obj.material && obj.material.dispose) {
            obj.material.dispose();
          }
        }
      });
      clusterCloudGroup = null;
    }

    function updateClouds(clusterPoints){
      clearClouds();
      clusterCloudGroup = new THREE.Group();

      const centroidVec = new THREE.Vector3();
      const tempVec = new THREE.Vector3();

      clusterPoints.forEach((pts, clusterId) => {
        // skip unassigned / tiny clusters
        if (clusterId < 0 || !pts || pts.length < 4) return;
        // no smoothing modifier; keep straight convex hull

        const hullPoints = pts.map(p => new THREE.Vector3(p.x, p.y, p.z));
        if (!hullPoints.length) return;

        // Convex hull geometry comes from the examples module, not the core THREE namespace
        const geom = new ConvexGeometry(hullPoints);
        const baseColor = new THREE.Color(palette[Math.abs(clusterId) % palette.length]);
        const isActive = (activeCentroid === null) || (activeCentroid === clusterId);

        const mat = new THREE.MeshStandardMaterial({
          color: baseColor,
          transparent: true,
          opacity: isActive ? 0.18 : 0.05,
          roughness: 0.85,
          metalness: 0.05,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geom, mat);
        mesh.scale.set(1.02, 1.02, 1.02); // push hull out just a bit
        clusterCloudGroup.add(mesh);
      });

      scene.add(clusterCloudGroup);
    }

    function update3D(){
      const n = points.length;
      const camDist = camera.position.distanceTo(controls3d?.target || new THREE.Vector3());
      const pointScale = THREE.MathUtils.clamp(camDist / 700, 1, 3.2);
      const farOpacityBoost = THREE.MathUtils.clamp((camDist - 600) / 700, 0, 1);
      const idQuat = new THREE.Quaternion();
      const scaleVec = new THREE.Vector3().setScalar(pointScale);
      if(planesVisible) updatePlaneOrigin();

      // Points grouped by cluster for per-cluster opacity
      if(pointsGroup) scene.remove(pointsGroup);
      pointsGroup = new THREE.Group();
      const clusterPoints = new Map();
      for(let i=0;i<n;i++){
        const a = assignments[i];
        if(!clusterPoints.has(a)) clusterPoints.set(a, []);
        clusterPoints.get(a).push(points[i]);
      }

      const personaLimit = Math.min(centroids.length, personaSlots.length, 4);
      clusterPoints.forEach((pts, clusterId)=>{
        const isPersonaCluster = clusterId >= 0 && clusterId < personaLimit;
        if(activeCentroid !== null && clusterId === activeCentroid && isPersonaCluster){
          // hide the original point spheres when the persona globe is shown
          return;
        }
        const active = (activeCentroid === null) || (clusterId === activeCentroid);
        const baseOpacity = Math.min(pointOpacity * (1 + farOpacityBoost * 0.6), 0.75);
        const opacity = active ? baseOpacity : Math.max(0.18, baseOpacity * 0.6);
        const sizeFactor = THREE.MathUtils.clamp(1 / pointScale, 0.3, 1); // higher when points are rendered smaller
        const emissiveBoost = THREE.MathUtils.lerp(1.0, 4.4, sizeFactor); // roughly doubled brightness
        const mat = new THREE.MeshPhysicalMaterial({
          vertexColors: true,
          color: 0xf2f7ff,
          emissive: 0xe4edff,
          emissiveIntensity: emissiveBoost,
          metalness: 1.0,
          roughness: 0.03,
          clearcoat: 0.6,
          clearcoatRoughness: 0.07,
          envMapIntensity: 2.6,
          transparent: true,
          opacity: Math.min(opacity, 0.6),
          depthWrite: false
        });
        const inst = new THREE.InstancedMesh(pointBaseGeom, mat, Math.max(1, pts.length));
        inst.userData.points = pts;
        inst.userData.clusterId = clusterId;
        const m = new THREE.Matrix4();
        const c = new THREE.Color("#ffffff");
        pts.forEach((p, idx)=>{
          m.compose(new THREE.Vector3(p.x, p.y, p.z), idQuat, scaleVec);
          inst.setMatrixAt(idx, m);
          inst.setColorAt(idx, c);
        });
        inst.instanceMatrix.needsUpdate = true;
        if(inst.instanceColor) inst.instanceColor.needsUpdate = true;
        pointsGroup.add(inst);
      });
      scene.add(pointsGroup);

      // Centroids
      centroidMeshes.forEach(m=> scene.remove(m));
      centroidMeshes = centroids.map((c,i)=>{
        const isPersona = i < personaCentroidColors.length;
        const baseHex = isPersona ? personaCentroidColors[i] : palette[i % palette.length];
        const base = new THREE.Color(baseHex);
        const emissive = base.clone().lerp(new THREE.Color(0xffffff), isPersona ? 0.5 : 0.35);
        const isActive = (activeCentroid === null) || (activeCentroid === i);
        const radius = isPersona ? 19 : 16;
        const visibleOpacity = isActive ? centroidOpacity : 0.15;
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(radius, 26, 20),
          new THREE.MeshStandardMaterial({
            color: base,
            emissive: emissive,
            emissiveIntensity: isPersona ? 1.8 : 1.25,
            metalness: isPersona ? 0.32 : 0.15,
            roughness: isPersona ? 0.16 : 0.22,
            transparent: true,
            opacity: isPersona ? Math.max(visibleOpacity, 0.55) : visibleOpacity
          })
        );
        if(isPersona){
          const halo = new THREE.Mesh(
            new THREE.SphereGeometry(radius * 1.4, 18, 14),
            new THREE.MeshBasicMaterial({
              color: base,
              transparent: true,
              opacity: 0.22,
              wireframe: true,
              depthWrite: false
            })
          );
          halo.renderOrder = 1;
          mesh.add(halo);
        }
        mesh.userData.index = i;
        mesh.position.set(c.x, c.y, c.z);
        scene.add(mesh);
        return mesh;
      });

      // Links: show only for active cluster if selected
      const useActive = activeCentroid !== null;
      const activeCount = useActive ? (clusterPoints.get(activeCentroid)?.length || 0) : n;
      const linkPos = new Float32Array(activeCount*2*3);
      let linkIdx = 0;
      function addLink(p, ccent){
        linkPos[linkIdx++] = p.x; linkPos[linkIdx++] = p.y; linkPos[linkIdx++] = p.z;
        linkPos[linkIdx++] = ccent.x; linkPos[linkIdx++] = ccent.y; linkPos[linkIdx++] = ccent.z;
      }
      if(useActive){
        const pts = clusterPoints.get(activeCentroid) || [];
        pts.forEach(p=>{
          const ccent = centroids[activeCentroid] || p;
          addLink(p, ccent);
        });
        linkMat.opacity = 0.5 * pointOpacity;
      }else{
        for(let i=0;i<n;i++){
          const p = points[i];
          const a = assignments[i];
          const ccent = a>=0 ? centroids[a] : p;
          addLink(p, ccent);
        }
        linkMat.opacity = 0.5 * pointOpacity;
      }
      linkGeom.dispose();
      linkGeom = new THREE.BufferGeometry();
      if(linkPos.length>0){
        linkGeom.setAttribute("position", new THREE.BufferAttribute(linkPos, 3));
      }
      linkLines.geometry = linkGeom;
      linkLines.visible = linkPos.length>0;

      // Axes
      ensureAxes();

      if (cloudsVisible) {
        updateClouds(clusterPoints);
      } else {
        clearClouds();
      }
    }


    // Animation loop
    function renderAxesOverlay(){
      if(!axesVisible || !axesScene || !axesCam || !axesGroup || !axesRenderer) return;
      axesGroup.quaternion.copy(camera.quaternion).invert(); // align so overlay matches scene movement
      const dist = 300;
      axesCam.position.set(0,0,dist);
      axesCam.up.copy(camera.up);
      axesCam.lookAt(0,0,0);
      axesCam.updateProjectionMatrix();
      axesRenderer.render(axesScene, axesCam);
    }

    function tick(){
      requestAnimationFrame(tick);
      controls3d.update();
      if(flyTween){
        const now = performance.now();
        const t = Math.min(1, (now - flyTween.startTime) / flyTween.duration);
        const ease = t*t*(3-2*t);
        const pos = flyTween.startPos.clone().lerp(flyTween.endPos, ease);
        const tgt = flyTween.startTarget.clone().lerp(flyTween.endTarget, ease);
        controls3d.setPose(pos, tgt);
        if(t >= 1){
          const arrivedInst = flyTween.inst;
          flyTween = null;
          showMetricsPanel(arrivedInst);
        }
      }
      updateVisibleGlobes();
      if(planeGroup){
        const inScene = planeGroup.parent === scene;
        if(planesVisible && !inScene) scene.add(planeGroup);
        if(!planesVisible && inScene) scene.remove(planeGroup);
      }
      renderer.render(scene, camera);
      renderAxesOverlay();
    }
    tick();

    function shuffle(arr){
      return arr.slice().sort(()=> Math.random()-0.5);
    }

    // Initial seed
    points = makePoints(+nSlider.input.value, +kSlider.input.value, +spreadSlider.input.value);
    update3D();
    updateLabels("idle");
    updateCountsFromSliders();
  </script>
</body>
</html>
